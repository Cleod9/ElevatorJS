package com.mcleodgaming.elevator.core{	import com.mcleodgaming.elevator.Main;	import com.mcleodgaming.elevator.core.*;	import com.mcleodgaming.elevator.events.*;	import com.mcleodgaming.elevator.util.*;	import flash.utils.*;	public class ElevatorEngine	{		//The ElevatorEngine acts as the "motherboard" of a group of Elevators		public static function generateFloors(amount:int):Array {			//Generate given amount of floors			var floors = new Array();			for(var i = 0; (i <= amount && amount >= 12) || (i < amount && amount < 12); i++)				if(amount < 12 || i != 12) /* Skip Floor 13!!! */					floors.push(new Floor({index: i, name: "" +(i+1) }));			return floors;		}		public static function generateElevators(amount:int, floors:Array, entranceFloor:Floor, currentFloor:Floor):Array {			//Generate given amount of elevators			var elevators = new Array();			for(var i = 0; i < amount; i++)				elevators.push(new Elevator({ name: "" + (i + 1), floors: floors, entranceFloor: entranceFloor, currentFloor: (currentFloor) ? currentFloor : null }));			return elevators;		}		public static function generatePeople(amount:int, floors:Array, entranceFloor:Floor, currentFloor:Floor):Array {			//Generate given amount of people			var people = new Array();			for(var i = 0; i < amount; i++) {				//Make a random floor				var targetFloor = floors[Math.round(Math.random()*(floors.length-1))];				while(targetFloor == currentFloor || targetFloor == entranceFloor)					targetFloor = floors[Math.round(Math.random()*(floors.length-1))];				var person = new Person({ name: RandomNameGenerator.getRandomName(), floorTimeMax: Math.round(Math.random()*(1000 - 250) + 250), entranceFloor: entranceFloor, currentFloor: (currentFloor) ? currentFloor : null, targetFloor: targetFloor });				people.push(person);				currentFloor.people.push(person);			}			return people;		}		public var started:Boolean; //Toggle if engine is on or off		public var ticker:*; //Reference to interval ticker		public var elevators:Array; //List of elevators		public var floors:Array; //List of floors		public var people:Array; //List of people		public var queue:Array; //Queue for when an up or down button is hit on a floor (determines when an elevator has acknowledged a floor)		public var entranceFloor:Floor;		public function ElevatorEngine(params:Object):void {			//Get settings			params = params || {};			elevators = params.elevators || new Array();			floors = params.floors || new Array();			people = params.people || new Array();			entranceFloor = (params.entranceFloor) ? params.entranceFloor : (floors.length > 0) ? floors[0] : null;			queue = new Array();			Debug.log("An ElevatorEngine has been created. { elevators: " + elevators.length + ", floors: " + floors.length + ", people: " + people.length + " } ");		}		public function start():void {			//Starts the ticker			if(!started) {				//Add all event listeners				EventDispatcher.dispatcher.addEventListener(PersonEvent.ENTERING, Main.eventHelper(this, onPersonEntering));				EventDispatcher.dispatcher.addEventListener(PersonEvent.LEAVING, Main.eventHelper(this, onPersonLeaving));				EventDispatcher.dispatcher.addEventListener(PersonEvent.BOARDED, Main.eventHelper(this, onPersonBoarded));				EventDispatcher.dispatcher.addEventListener(PersonEvent.DEPARTED, Main.eventHelper(this, onPersonDeparted));				EventDispatcher.dispatcher.addEventListener(PersonEvent.DONE, Main.eventHelper(this, onPersonDone));				EventDispatcher.dispatcher.addEventListener(ElevatorEvent.ARRIVE, Main.eventHelper(this, onElevatorArrive));				EventDispatcher.dispatcher.addEventListener(ElevatorEvent.DEPART, Main.eventHelper(this, onElevatorDepart));				EventDispatcher.dispatcher.addEventListener(ElevatorEvent.FULL, Main.eventHelper(this, onElevatorFull));				EventDispatcher.dispatcher.addEventListener(ElevatorEvent.RESPOND, Main.eventHelper(this, onElevatorRespond));				//Enable ticker				started = true;				ticker = setInterval(Main.eventHelper(this, tick), (1000 / Main.FPS));				Debug.log("ElevatorEngine started.");			} else {				Debug.log("Engine already started");			}		}		public function stop():void {			//Stops the ticker			if(started) {				//Remove all event listeners				EventDispatcher.dispatcher.removeEventListener(PersonEvent.ENTERING);				EventDispatcher.dispatcher.removeEventListener(PersonEvent.LEAVING);				EventDispatcher.dispatcher.removeEventListener(PersonEvent.BOARDED);				EventDispatcher.dispatcher.removeEventListener(PersonEvent.DEPARTED);				EventDispatcher.dispatcher.removeEventListener(PersonEvent.DONE);				EventDispatcher.dispatcher.removeEventListener(ElevatorEvent.ARRIVE);				EventDispatcher.dispatcher.removeEventListener(ElevatorEvent.DEPART);				EventDispatcher.dispatcher.removeEventListener(ElevatorEvent.FULL);				EventDispatcher.dispatcher.removeEventListener(ElevatorEvent.RESPOND);				//Turn off ticker				started = false;				clearInterval(ticker);				ticker = null;				Debug.log("ElevatorEngine stopped.");			} else {				Debug.log("Engine already stopped");			}		}		public function tick(e:* = null):void {			//Function to perform each tick (the main loop)			var  i;			//Evaluate queue			processQueue();			//Run ticks			for(i = 0; i < elevators.length; i++)				elevators[i].tick();			for(i = 0; i < people.length; i++) {				people[i].tick();			}			//Get rid of all people who have left			for(i = 0; i < people.length; i++)				if(people[i].state == PersonState.DONE)					people.splice(i--, 1);			EventDispatcher.dispatcher.dispatchEvent(new ElevatorEngineEvent(ElevatorEngineEvent.UPDATE, { engine: this }));		}		public function addPerson(person:Person):void {			//Person enters the building			people.push(person);		}		public function processQueue():void {			//Process the floor queue (basically simulates the user hitting the up or down button)			var e, p;			for(p = 0; p < queue.length; p++) {				if(!queue[p].currentFloor) {					//They must have already boarded an elevator					queue.splice(p--, 1);					continue;				}				//Use the Elevator's comparePriority() function to determine the best elevator				//Note: I'm looping backwards since my "best elevator" logic will priortize elevators on the "opposite" end of where it starts checking				var bestElevator = null;				for(e = elevators.length - 1; e >= 0; e--)					bestElevator = elevators[e].comparePriority(bestElevator, queue[p].currentFloor, (queue[p].targetFloor.index > queue[p].currentFloor.index));								//If a best elevator was found				if(bestElevator) {					//Only queue floor if there is not already another elevator on this floor already that's accepting people					for(e = 0; e < elevators.length; e++)						if(elevators[e] != bestElevator && elevators[e].state == ElevatorState.WAITING && elevators[e].currentFloor == queue[p].currentFloor)							bestElevator = elevators[e];					//Officially queue the elevator					bestElevator.queueFloor(queue[p].currentFloor);					queue.splice(p--, 1);				}			}		}		public function onPersonEntering(event:PersonEvent):void {			queue.push(event.data.person);			Debug.log(event.data.person.name + " entered the building on floor: " + event.data.floor.name + " (target floor: " + event.data.person.targetFloor.name + ")");		}		public function onPersonLeaving(event:PersonEvent):void {			queue.push(event.data.person);			Debug.log(event.data.person.name + " is ready to leave floor: " + event.data.floor.name);		}		public function onPersonBoarded(event:PersonEvent):void {			Debug.log(event.data.person.name + " boarded elevator " + event.data.elevator.name + ' from floor ' + event.data.elevator.currentFloor.name + ' (going to floor ' + event.data.person.targetFloor.name + ')');		}		public function onPersonDeparted(event:PersonEvent):void {			Debug.log(event.data.person.name + " departed elevator " + event.data.elevator.name + ' (from floor ' + event.data.person.currentFloor.name + ')');		}		public function onPersonDone(event:PersonEvent):void {			Debug.log(event.data.person.name + " has left the building.");		}		public function onElevatorRespond(event:ElevatorEvent):void {			//When an elevator fills up			Debug.log("Elevator " + event.data.elevator.name + " responded to the request from floor " + event.data.floor.name + ' (currently at floor ' + event.data.elevator.currentFloor.name + ' )');		}		public function onElevatorArrive(event:ElevatorEvent):void {			//When an elevator arrives on a floor, let other elevators know perhaps?			for(var i = 0; i < elevators.length; i++) {				if(elevators[i] != event.data.elevator && elevators[i].targetFloors.indexOf(event.data.floor) >= 0) {					//TODO: Allow elevator to change course or something under certain conditions?				}			}			var nextFloor = (event.data.elevator.nextFloor()) ? event.data.elevator.nextFloor().name : null;			Debug.log("Elevator " + event.data.elevator.name + " arrived on floor " + event.data.floor.name + ' (nextFloor: ' + nextFloor + ', people: ' + event.data.elevator.people.length + ', targetFloors: ' + event.data.elevator.targetFloors.length + ' )');		}		public function onElevatorDepart(event:ElevatorEvent):void {			//When an elevator departs a floor			var nextFloor = (event.data.elevator.nextFloor()) ? event.data.elevator.nextFloor().name : null;			Debug.log("Elevator " + event.data.elevator.name + " departed floor " + event.data.floor.name + ' (nextFloor: ' + nextFloor + ', people: ' + event.data.elevator.people.length + ', targetFloors: ' + event.data.elevator.targetFloors.length + ' )');		}		public function onElevatorFull(event:ElevatorEvent):void {			//When an elevator fills up			Debug.log("Elevator " + event.data.elevator.name + " was full and denied " + event.data.person.name + ' access at floor ' + event.data.floor.name + ' )');		}	}}