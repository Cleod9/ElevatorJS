package com.mcleodgaming.elevator.core{	import com.mcleodgaming.elevator.core.*;	import com.mcleodgaming.elevator.events.*;	import com.mcleodgaming.elevator.util.*;	//A Person is the entity that can occupy a floor or elevator. They enter the building with a target floor, and leave after a certain period of ticks	public class Person	{		public var name:String; //Name for the person		public var state:int; //PersonState value		public var entranceFloor:Floor; //Entrance floor reference so they know how to get back		public var currentFloor:Floor; //The current floor they are on		public var targetFloor:Floor; //The target floor they want to go to		public var currentElevator:Elevator; //The current elevator they are on		public var floorTimer:FrameTimer; //Timer for how long the Person wants to wait on the floor		public var waitTimer:int; //How long the Person has waited for an elevator since pressing the button		public function Person(params:Object):void {			//Get settings			params = params || {};			name = params.name || "Unknown";			entranceFloor = (params.entranceFloor) ? params.entranceFloor : null;			currentFloor = (params.currentFloor) ? params.currentFloor : null;			targetFloor = (params.targetFloor) ? params.targetFloor : null;			floorTimer = new FrameTimer(params.floorTimer || 1000);			state = params.state || PersonState.QUEUEING;			waitTimer = 0;		}		public function isReady():Boolean {			//Returns true if the person is ready to leave their floor			return floorTimer.IsComplete;		}		public function resetTime():void {			//Resets the amount of time the user wants to remain on the floor			floorTimer.reset();		}		public function waitTime():int {			//Returns the total time the user has been in the isReady() state and been stuck waiting			return waitTimer;		}		public function boardElevator(elevator:Elevator):void {			//Leave floor, enter elevator			var oldFloor = currentFloor;			currentElevator = elevator;			currentFloor.removePerson(this);			currentFloor = null;			EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.BOARDED, { elevator: elevator, person: this, floor: oldFloor }));		}		public function exitElevator(floor:Floor):void {			//Exit elevator, enter floor			var tmpElevator = currentElevator;			currentElevator = null;			var tmpFloor = currentFloor = floor;			currentFloor.addPerson(this);			resetTime();			if(state == PersonState.ENTERING) {				//They are just entering the building so now they want to stay IDLE on this floor				state = PersonState.IDLE;				EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.DEPARTED, { elevator: tmpElevator, person: this, floor: currentFloor }));				EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.WAITING, { person: this }));			} else if(state == PersonState.LEAVING) {				//The person had been on their way out of the building, so have them enter their DONE state				EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.DEPARTED, { elevator: tmpElevator, person: this, floor: tmpFloor }));				currentFloor.removePerson(this);				currentFloor = null;				state = PersonState.DONE;				EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.DONE, { person: this, floor: tmpFloor }));			} else {				//This state should be impossible				throw new Error("[Person] Some Unhandled state in Person");			}		}		public function tick():void {			if(state == PersonState.QUEUEING) {				//Immediately allow the person into their ENTERING state (QUEING state is just so we can do a one-time ENTERING event trigger)				state = PersonState.ENTERING;				EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.ENTERING, { person: this, floor: currentFloor }));			} else if(state == PersonState.IDLE) {				//The person is IDLING on a floor				if(currentFloor) {					floorTimer.tick();					if(floorTimer.IsComplete) {						//The person is done on the floor, they want to enter LEAVING state						waitTimer = 0;						floorTimer.reset();						state = PersonState.LEAVING;						targetFloor = entranceFloor;						EventDispatcher.dispatcher.dispatchEvent(new PersonEvent(PersonEvent.LEAVING, { person: this, floor: currentFloor }));					}				}			} else if((state == PersonState.LEAVING || state ==PersonState.ENTERING) && !currentElevator) {				waitTimer++;			}		}	}};